
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SimCity 3D Test</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100%; }
        #hud { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="hud">
        <p>FPS: <span id="fps">0</span></p>
        <p>Buildings: <span id="buildingCount">0</span></p>
    </div>

    <script type="module">
        // WebGPU initialization
        async function initWebGPU() {
            if (!navigator.gpu) {
                alert("WebGPU not supported!");
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const canvas = document.getElementById("canvas");
            const context = canvas.getContext("webgpu");
            const format = navigator.gpu.getPreferredCanvasFormat();

            context.configure({ device, format });
            return { device, context, format };
        }

        // Simple vertex and fragment shaders for 3D buildings
        const vertexShader = `
            @vertex
            fn main(@location(0) position: vec3<f32>) -> @builtin(position) vec4<f32> {
                return vec4<f32>(position, 1.0);
            }
        `;

        const fragmentShader = `
            @fragment
            fn main() -> @location(0) vec4<f32> {
                return vec4<f32>(0.0, 0.5, 1.0, 1.0); // Blue buildings
            }
        `;

        // Main rendering function
        async function main() {
            const { device, context, format } = await initWebGPU();
            const aspect = window.innerWidth / window.innerHeight;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Pipeline setup
            const pipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: {
                    module: device.createShaderModule({ code: vertexShader }),
                    entryPoint: "main",
                    buffers: [{
                        arrayStride: 12,
                        attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
                    }]
                },
                fragment: {
                    module: device.createShaderModule({ code: fragmentShader }),
                    entryPoint: "main",
                    targets: [{ format }]
                },
                primitive: { topology: "triangle-list" }
            });

            // Simple building (cube) vertex data
            const vertices = new Float32Array([
                -0.1, -0.1, -0.1,  0.1, -0.1, -0.1,  0.1, 0.1, -0.1, // Front face
                -0.1, -0.1, -0.1,  -0.1, 0.1, -0.1,  0.1, 0.1, -0.1,
                // Add more faces for a cube...
            ]);

            const vertexBuffer = device.createBuffer({
                size: vertices.byteLength,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
            });
            device.queue.writeBuffer(vertexBuffer, 0, vertices);

            // HUD elements
            let buildingCount = 1;
            const fpsDisplay = document.getElementById("fps");
            const buildingDisplay = document.getElementById("buildingCount");
            buildingDisplay.textContent = buildingCount;

            // Animation loop
            let lastTime = performance.now();
            function render() {
                const now = performance.now();
                fpsDisplay.textContent = Math.round(1000 / (now - lastTime));
                lastTime = now;

                const commandEncoder = device.createCommandEncoder();
                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        clearValue: { r: 0.2, g: 0.2, b: 0.2, a: 1.0 },
                        loadOp: "clear",
                        storeOp: "store"
                    }]
                });

                renderPass.setPipeline(pipeline);
                renderPass.setVertexBuffer(0, vertexBuffer);
                renderPass.draw(6, 1, 0, 0); // Draw one building
                renderPass.end();
                device.queue.submit([commandEncoder.finish()]);

                requestAnimationFrame(render);
            }
            render();
        }

        main().catch(console.error);
    </script>
</body>
</html>
    