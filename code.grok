// Contenu de Arborescence.js
const fs = require('fs').promises;
const path = require('path');

async function scanDirectory(dir, prefix = '', visited = new Set()) {
    try {
        const realPath = await fs.realpath(dir);
        if (visited.has(realPath)) return '';
        visited.add(realPath);

        const files = await fs.readdir(dir, { withFileTypes: true });
        const filteredFiles = files
            .filter(file => !file.name.startsWith('.'))
            .sort((a, b) => {
                if (a.isDirectory() === b.isDirectory()) {
                    return a.name.localeCompare(b.name, 'fr', { sensitivity: 'base' });
                }
                return a.isDirectory() ? -1 : 1;
            });

        let result = '';
        for (let i = 0; i < filteredFiles.length; i++) {
            const file = filteredFiles[i];
            const isLast = i === filteredFiles.length - 1;
            const filePath = path.join(dir, file.name);
            const suffix = file.isDirectory() ? '/' : '';
            result += `${prefix}${isLast ? '└── ' : '├── '}${file.name}${suffix}\n`;

            if (file.isDirectory()) {
                const newPrefix = `${prefix}${isLast ? '    ' : '│   '}`;
                result += await scanDirectory(filePath, newPrefix, visited);
            }
        }
        return result;
    } catch (error) {
        console.warn(`Impossible de scanner ${dir}: ${error.message}`);
        return '';
    }
}

async function generateArborescence(outputFile = 'Arborescence.grok') {
    try {
        const arborescence = await scanDirectory(__dirname);
        await fs.writeFile(
            path.join(__dirname, outputFile),
            arborescence,
            { encoding: 'utf8' }
        );
        console.log(`Fichier ${outputFile} généré avec succès`);

        const { listFunctionsInJsFiles } = require('./Fonctions.js');
        await listFunctionsInJsFiles();
    } catch (error) {
        console.error('Erreur lors de la génération :', error.message);
        throw error;
    }
}

if (require.main === module) {
    generateArborescence().catch(error => {
        console.error('Échec de l\'exécution:', error.message);
        process.exit(1);
    });
}

module.exports = { scanDirectory, generateArborescence };


// Contenu de Code.js
const fs = require('fs');
const path = require('path');

function scanDirectory(dir) {
    let results = [];
    const files = fs.readdirSync(dir, { withFileTypes: true });
    for (const file of files) {
        const fullPath = path.join(dir, file.name);
        if (file.isDirectory()) {
            results = results.concat(scanDirectory(fullPath));
        } else if (file.name.endsWith('.js') && file.name !== 'UpdateProject.js') {
            results.push(fullPath);
        }
    }
    return results;
}

function writeCodeGrok() {
    const projectDir = __dirname;
    const jsFiles = scanDirectory(projectDir);
    let codeContent = '';

    for (const file of jsFiles) {
        const content = fs.readFileSync(file, 'utf8');
        codeContent += `// Contenu de ${path.relative(projectDir, file)}
${content}

`;
    }

    fs.writeFileSync(path.join(projectDir, 'code.grok'), codeContent);
    console.log('code.grok créé avec succès.');
}

writeCodeGrok();


// Contenu de Fonctions.js
const fs = require('fs');
const path = require('path');

function listFunctionsInJsFiles() {
    const dir = path.join(__dirname);
    const functionList = [];

    function scanDirectory(directory) {
        const files = fs.readdirSync(directory, { withFileTypes: true });
        files.forEach(file => {
            const filePath = path.join(directory, file.name);
            if (file.isDirectory()) {
                scanDirectory(filePath);
            } else if (file.name.endsWith('.js')) {
                const content = fs.readFileSync(filePath, 'utf8');
                const functionRegex = /(?:function\s+([a-zA-Z_]\w*)\s*\([^)]*\)|const\s+([a-zA-Z_]\w*)\s*=\s*\([^)]*\)\s*=>|([a-zA-Z_]\w*)\s*:\s*function\s*\([^)]*\))/g;
                let match;
                while ((match = functionRegex.exec(content)) !== null) {
                    const relativePath = path.relative(__dirname, filePath);
                    const functionName = match[1] || match[2] || match[3];
                    functionList.push(`${relativePath}: ${functionName}`);
                }
            }
        });
    }

    try {
        scanDirectory(dir);
        const outputPath = path.join(__dirname, 'Fonctions.grok');
        fs.writeFileSync(outputPath, functionList.join('\n'), 'utf8');
        console.log(`Successfully wrote ${functionList.length} functions to Fonctions.grok`);
        return functionList;
    } catch (error) {
        console.error('Error processing files:', error);
        return [];
    }
}

module.exports = { listFunctionsInJsFiles };

if (require.main === module) {
    listFunctionsInJsFiles();
}


// Contenu de Readme.js
const fs = require('fs');
const path = require('path');

function updateReadme() {
    console.log('Mise à jour de README.md...');
    
    const readmeContent = `![Generated Image](./generated_image.jpg)

# ProjectManager

## Description
ProjectManager est un outil de gestion de projet automatisé utilisant Node.js et Git. Il permet d'initialiser, mettre à jour et gérer un dépôt GitHub, de générer une arborescence de fichiers, de lister les fonctions des fichiers JS, et de regrouper le code dans un fichier exploitable.

## Prérequis
- Node.js installé
- Git installé et configuré
- Accès au dépôt GitHub : [https://github.com/therealvan/ProjectManager](https://github.com/therealvan/ProjectManager)

## Structure du projet
\`\`\`
├── src/
│   └── GitHub/
│       ├── DiagGitHub.js  # Logs d'erreurs
│       └── GitHub.js      # Fonctions Git
├── Arborescence.js        # Génère l'arborescence
├── Code.js                # Regroupe le code JS
├── Fonctions.js           # Liste les fonctions
├── Readme.js              # Met à jour ce README
├── StartProject.js        # Initialise le projet
├── UpdateProject.js       # Met à jour le projet
├── README.md              # Ce fichier
├── Branche.git            # Branche active
└── *.grok                 # Fichiers générés
\`\`\`

## Fonctionnalités
- Clonage du dépôt depuis GitHub
- Nettoyage et gestion des fichiers locaux
- Création et suppression de branches distantes
- Push forcé priorisant le local
- Génération d’arborescence et de listes de fonctions
- Mise à jour automatique du README à chaque push

## Contribution
1. Forkez le projet
2. Créez une branche pour vos modifications
3. Soumettez une pull request

## Dernière mise à jour
${new Date().toLocaleString('fr-FR')}

## Licence
Aucune licence spécifiée pour le moment.
`;

    fs.writeFileSync(path.join(__dirname, 'README.md'), readmeContent, 'utf8');
    console.log('README.md mis à jour avec succès.');
}

module.exports = { updateReadme };

if (require.main === module) {
    updateReadme();
}


// Contenu de src\GitHub\DiagGitHub.js
function log(message) {
    console.error("Erreur détectée : " + message);
}
module.exports = { log };


// Contenu de src\GitHub\GitHub.js
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

function verifyGitSuccess() {
    try {
        execSync('git --version', { stdio: 'pipe' });
        return true;
    } catch (error) {
        return false;
    }
}

function getCurrentBranch() {
    const branchFile = path.join(__dirname, '..', '..', 'Branche.git');
    let branchName;
    try {
        branchName = fs.readFileSync(branchFile, 'utf8').trim();
    } catch (error) {
        branchName = 'V1.0.0'; // Branche par défaut
    }
    return branchName;
}

function cloneOrUpdateRepo(repoUrl, dir) {
    execSync(`git clone ${repoUrl} ${dir} || git -C ${dir} pull`, { stdio: 'inherit' });
}

function listLocalFiles() {
    return fs.readdirSync('.');
}

function addFiles(files) {
    execSync(`git add ${files}`, { stdio: 'inherit' });
}

function commitChanges(message) {
    execSync(`git commit -m "${message}"`, { stdio: 'inherit' });
}

function pushChanges() {
    const branch = getCurrentBranch();
    try {
        // Mise à jour du README avant le push
        const { updateReadme } = require(path.join(__dirname, '..', '..', 'Readme.js'));
        updateReadme();
        
        const status = execSync('git status --porcelain', { encoding: 'utf8' });
        if (status.trim().length === 0) {
            console.log('Aucune modification locale à pousser.');
            return;
        }
        addFiles('.');
        try {
            commitChanges('Mise à jour automatique du projet');
        } catch (commitError) {
            console.log('Rien de nouveau à committer.');
        }
        execSync(`git push origin ${branch} --force`, { stdio: 'inherit' });
        console.log(`Code local poussé avec succès sur ${branch} (force).`);
    } catch (error) {
        console.error('Erreur lors du push :', error.message);
    }
}

function pullChanges() {
    const branch = getCurrentBranch();
    execSync(`git pull origin ${branch}`, { stdio: 'inherit' });
}

function createBranch(branchName) {
    const currentBranch = getCurrentBranch();
    try {
        execSync(`git push origin ${currentBranch}:${branchName}`, { stdio: 'inherit' });
        console.log(`Branche distante "${branchName}" créée avec succès depuis "${currentBranch}".`);
    } catch (error) {
        console.error(`Erreur lors de la création de la branche distante "${branchName}" : ${error.message}`);
    }
}

function createRelease(version) {
    execSync(`git tag ${version} && git push origin ${version}`, { stdio: 'inherit' });
}

function checkoutBranch(branchName) {
    execSync(`git checkout ${branchName}`, { stdio: 'inherit' });
}

function mergeBranch(branchName) {
    execSync(`git merge ${branchName}`, { stdio: 'inherit' });
}

function deleteBranch(branchName) {
    try {
        execSync(`git push origin --delete ${branchName}`, { stdio: 'inherit' });
        console.log(`Branche distante "${branchName}" supprimée avec succès.`);
    } catch (error) {
        console.error(`Erreur lors de la suppression de la branche distante "${branchName}" : ${error.message}`);
    }
}

function status() {
    execSync('git status', { stdio: 'inherit' });
}

function fetchRepo() {
    execSync('git fetch', { stdio: 'inherit' });
}

function stashChanges() {
    execSync('git stash', { stdio: 'inherit' });
}

function applyStash() {
    execSync('git stash pop', { stdio: 'inherit' });
}

function resetChanges() {
    execSync('git reset --hard', { stdio: 'inherit' });
}

function logCommits() {
    execSync('git log', { stdio: 'inherit' });
}

function diffChanges() {
    execSync('git diff', { stdio: 'inherit' });
}

module.exports = {
    verifyGitSuccess, getCurrentBranch, cloneOrUpdateRepo, listLocalFiles,
    addFiles, commitChanges, pushChanges, pullChanges, createBranch,
    createRelease, checkoutBranch, mergeBranch, deleteBranch, status,
    fetchRepo, stashChanges, applyStash, resetChanges, logCommits, diffChanges
};


// Contenu de StartProject.js
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const REPO_URL = 'https://github.com/therealvan/ProjectManager.git';
const PROJECT_DIR = path.join(__dirname);

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function startProject() {
    console.log('Démarrage de StartProject.js...');
    console.log('-------------');

    try {
        console.log('Vérification de Git...');
        execSync('git --version', { stdio: 'inherit' });
        console.log('Étape 1 : Git OK.');
    } catch (error) {
        console.error('Étape 1 : Erreur - Git n’est pas installé ou inaccessible :', error.message);
        console.log('Veuillez installer Git manuellement ou via npm.');
        return;
    }
    console.log('-------------');

    try {
        console.log('Vérification et nettoyage du dossier principal :', PROJECT_DIR);
        if (!fs.existsSync(PROJECT_DIR)) {
            fs.mkdirSync(PROJECT_DIR, { recursive: true });
            console.log('Dossier ProjectManager créé.');
        }
        const files = fs.readdirSync(PROJECT_DIR);
        for (const file of files) {
            if (file !== 'StartProject.js' && file !== 'UpdateProject.js') {
                const filePath = path.join(PROJECT_DIR, file);
                let retries = 3;
                while (retries > 0) {
                    try {
                        if (fs.lstatSync(filePath).isDirectory()) {
                            fs.rmSync(filePath, { recursive: true, force: true });
                        } else {
                            fs.unlinkSync(filePath);
                        }
                        break;
                    } catch (err) {
                        if (err.code === 'EBUSY') {
                            console.log(`Fichier ${file} verrouillé, attente 1s...`);
                            await delay(1000);
                            retries--;
                            if (retries === 0) throw err;
                        } else {
                            throw err;
                        }
                    }
                }
            }
        }
        console.log('Étape 2 : Dossier nettoyé, seuls StartProject.js et UpdateProject.js restent.');
        process.chdir(PROJECT_DIR);
        console.log('Répertoire de travail changé à :', process.cwd());
    } catch (error) {
        console.error('Étape 2 : Erreur lors du nettoyage ou de la préparation du dossier :', error.message);
        return;
    }
    console.log('-------------');

    try {
        console.log('Lancement du clonage à la racine...');
        const tempDir = path.join(PROJECT_DIR, 'temp_repo');
        if (fs.existsSync(tempDir)) {
            let retries = 3;
            while (retries > 0) {
                try {
                    fs.rmSync(tempDir, { recursive: true, force: true });
                    break;
                } catch (err) {
                    if (err.code === 'EBUSY') {
                        console.log('Dossier temp_repo verrouillé, attente 1s...');
                        await delay(1000);
                        retries--;
                        if (retries === 0) throw err;
                    } else {
                        throw err;
                    }
                }
            }
        }
        execSync(`git clone -b V1.0.0 ${REPO_URL} ${tempDir}`, { stdio: 'inherit' });
        const tempFiles = fs.readdirSync(tempDir);
        for (const file of tempFiles) {
            if (file !== '.git') {
                let retries = 3;
                while (retries > 0) {
                    try {
                        fs.renameSync(path.join(tempDir, file), path.join(PROJECT_DIR, file));
                        break;
                    } catch (err) {
                        if (err.code === 'EBUSY') {
                            console.log(`Fichier ${file} verrouillé, attente 1s...`);
                            await delay(1000);
                            retries--;
                            if (retries === 0) throw err;
                        } else {
                            throw err;
                        }
                    }
                }
            }
        }
        fs.renameSync(path.join(tempDir, '.git'), path.join(PROJECT_DIR, '.git'));
        fs.rmSync(tempDir, { recursive: true, force: true });
        console.log('Étape 3 : Dépôt cloné avec succès à la racine sur la branche V1.0.0.');
    } catch (error) {
        console.error('Étape 3 : Erreur lors du clonage :', error.message);
        return;
    }
    console.log('-------------');

    try {
        console.log('Vérification des fichiers locaux à la racine...');
        const files = fs.readdirSync('.', { withFileTypes: true });
        const fileList = files.map(item => item.isDirectory() ? item.name + '/' : item.name);
        console.log('Fichiers locaux après clonage :', fileList);
        console.log('Étape 4 : Contenu local vérifié.');
    } catch (error) {
        console.error('Étape 4 : Erreur lors de la vérification :', error.message);
        return;
    }
    console.log('-------------');

    try {
        console.log('Lancement de Arborescence.js...');
        const arborescence = require(path.join(PROJECT_DIR, 'Arborescence.js'));
        arborescence.generateArborescence();
        console.log('Étape 5 : Arborescence.js exécuté avec succès.');
    } catch (error) {
        console.error('Étape 5 : Erreur lors de l’exécution de Arborescence.js :', error.message);
    }
    console.log('-------------');

    try {
        console.log('Exécution de Fonctions.js...');
        const fonctions = require(path.join(PROJECT_DIR, 'Fonctions.js'));
        fonctions.listFunctionsInJsFiles();
    } catch (error) {
        console.error('Erreur lors de l’exécution de Fonctions.js :', error.message);
    }

    try {
        console.log('Lancement final de Arborescence.js...');
        const arborescence = require(path.join(PROJECT_DIR, 'Arborescence.js'));
        arborescence.generateArborescence();
    } catch (error) {
        console.error('Erreur lors de l’exécution finale de Arborescence.js :', error.message);
    }

    console.log('Terminé !');

    try {
        console.log('Récupération de la branche active...');
        const branch = execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf8' }).trim();
        fs.writeFileSync('Branche.git', branch);
        console.log('Branche active (' + branch + ') écrite dans Branche.git.');
    } catch (error) {
        console.error('Erreur lors de la récupération de la branche :', error.message);
    }
}

try {
    console.log('Tentative d’exécution de startProject...');
    startProject().catch(err => console.error('Erreur globale dans StartProject.js :', err.message));
} catch (error) {
    console.error('Erreur globale dans StartProject.js :', error.message);
}

module.exports = { startProject };


